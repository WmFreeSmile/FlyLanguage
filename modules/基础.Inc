


Sub 工作线程 stdcall(初始信息 As 初始信息类型 Ptr)
   Dim 不进行任何返回  As BOOL
   Dim 返回值地址_容器 As 容器类型 Ptr
   
   Dim 基地址 As Integer = 初始信息->基地址
   Dim 模块索引 As Integer = 初始信息->模块索引
   
   If 初始信息->返回值地址 = 0 Then
      不进行任何返回 = True
   Else
      返回值地址_容器 = 初始信息->返回值地址
   End If
   
   Dim 栈() As 栈类型
   Dim 栈顶 As Integer = 0
   
   Dim 调用栈() As 调用栈类型
   Dim 调用栈顶 As Integer = 0
   
   ReDim 栈(UBound(初始信息->初始栈))
   For i As Integer = 0 To UBound(初始信息->初始栈)
      栈(i) = 初始信息->初始栈(i)
      栈顶  = 栈顶 + 1
   Next
   
   ReDim Preserve 栈(执行栈尺寸 -1)
   ReDim Preserve 调用栈(调用栈尺寸 -1)
   
   调用栈(调用栈顶).回转地址 = -1
   调用栈(调用栈顶).重定义容器上限(容器数量 -1)
   调用栈(调用栈顶).重定义循环栈上限(循环栈尺寸 -1)
   调用栈(调用栈顶).重定义变量循环栈上限(变量循环栈尺寸 -1)
   
   Dim 指令索引 As ULongInt
   Dim 现行指令索引 As ULongInt
   Dim 相对索引 As ULongInt
   相对索引 = 初始信息->初始地址
   
   Delete(初始信息)
   
   If 调试模式 Then
      '没有写没有写没有写
   End If
   
   Dim 临时栈 As 栈类型
   
   指令索引 = 基地址 + 相对索引
   
   Dim 栈参数_0 As 栈类型 Ptr
   Dim 栈参数_1 As 栈类型 Ptr
   Dim 栈参数_2 As 栈类型 Ptr
   Dim 栈参数_3 As 栈类型 Ptr
   Dim 栈参数_4 As 栈类型 Ptr
   Dim 栈参数_5 As 栈类型 Ptr
   
   While True
      现行指令索引 = 指令索引
      指令索引 += 1
      
      'EnterCriticalSection(@临界资源_指令执行)
      'Print IS_GetStr(指令表(现行指令索引).指令) ,现行指令索引 ,GetCurrentThreadId()
      ''Sleep
      'LeaveCriticalSection(@临界资源_指令执行)
      
      Select Case As Const 指令表(现行指令索引).指令
         Case is_nop
            
         Case is_push
            Select Case As Const CPtr(is_push_type Ptr ,指令表(现行指令索引).数据)->类型
               Case Push_压入容器
                  Dim 容器序号 As LongInt
                  
                  容器序号 = CPtr(is_push_type Ptr ,指令表(现行指令索引).数据)->容器序号
                  
                  If 容器序号 < 0 Then
                     容器序号 = Abs(容器序号) -1
                     
                     Select Case As Const 模块表(模块索引).全局容器(容器序号).类型
                        Case 容器类型_值
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = @模块表(模块索引).全局容器(容器序号)
                        Case 容器类型_容器指针
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = 模块表(模块索引).全局容器(容器序号).容器指针
                        Case 容器类型_容器组
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = @模块表(模块索引).全局容器(容器序号)
                     End Select
                  Else
                     Select Case As Const 调用栈(调用栈顶).容器(容器序号).类型
                        Case 容器类型_值
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = @调用栈(调用栈顶).容器(容器序号)
                        Case 容器类型_容器指针
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = 调用栈(调用栈顶).容器(容器序号).容器指针
                        Case 容器类型_容器组
                           临时栈.类型   = 栈_容器
                           临时栈.栈空间.容器值 = @调用栈(调用栈顶).容器(容器序号)
                     End Select
                  End If
                  压入(栈 ,栈顶 ,临时栈)
               Case Push_压入整数
                  临时栈.类型   = 栈_整数
                  临时栈.栈空间.整数值 = CPtr(is_push_type Ptr ,指令表(现行指令索引).数据)->整数值
                  
                  压入(栈 ,栈顶 ,临时栈)
               Case Push_压入文本
                  临时栈.类型   = 栈_文本
                  临时栈.文本值 = CPtr(is_push_type Ptr ,指令表(现行指令索引).数据)->文本值
                  
                  压入(栈 ,栈顶 ,临时栈)
               Case Push_压入小数
                  临时栈.类型   = 栈_小数
                  临时栈.栈空间.小数值 = CPtr(is_push_type Ptr ,指令表(现行指令索引).数据)->小数值
                  
                  压入(栈 ,栈顶 ,临时栈)
               Case Push_压入相对地址
                  临时栈.类型 = 栈_地址
                  
                  If CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->绝对地址 <> 0 Then
                     临时栈.栈空间.地址 = CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->绝对地址
                  Else
                     CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->绝对地址 = 现行指令索引 + CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->相对地址
                     临时栈.栈空间.地址 = CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->绝对地址
                  End If
                  
                  压入(栈, 栈顶, 临时栈)
               Case Push_压入数据
                  临时栈.类型 = 栈_数据
                  临时栈.数据值 = CPtr(is_push_type Ptr, 指令表(现行指令索引).数据)->数据值
                  
                  压入(栈, 栈顶, 临时栈)
            End Select
         Case is_pop
            '0:弹出的值
            '1:存放位置
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_1->栈空间.容器值->拷贝(栈参数_0->栈空间.容器值)
            ElseIf 栈参数_0->类型 = 栈_整数 Then
               栈参数_1->栈空间.容器值->对象->整数值 = 栈参数_0->栈空间.整数值
            ElseIf 栈参数_0->类型 = 栈_文本 Then
               栈参数_1->栈空间.容器值->对象->文本值 = 栈参数_0->文本值
            ElseIf 栈参数_0->类型 = 栈_小数 Then
               栈参数_1->栈空间.容器值->对象->小数值 = 栈参数_0->栈空间.小数值
            ElseIf 栈参数_0->类型 = 栈_地址 Then
               栈参数_1->栈空间.容器值->对象->整数值 = 栈参数_0->栈空间.地址
            ElseIf 栈参数_0->类型 = 栈_数据 Then
               栈参数_1->栈空间.容器值->对象->数据值 = 栈参数_0->数据值
            End If
         Case is_popn
            栈顶 = 栈顶 -1
         Case is_jmp
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 地址 As ULongInt
            If 栈参数_0->类型 = 栈_地址 Then
               地址 = 栈参数_0->栈空间.地址
            ElseIf 栈参数_0->类型 = 栈_容器 Then
               If 栈参数_0->栈空间.容器值->对象->类型 = 类型_整数 Then
                  地址 = 栈参数_0->栈空间.容器值->对象->整数值
               End If
            ElseIf 栈参数_0->类型 = 栈_整数 Then
               地址 = 栈参数_0->栈空间.整数值
            End If
            
            指令索引 = 地址
         Case is_je
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            
            Dim 条件a As 对象类型 Ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 = 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 = 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 = 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 = 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 = 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               临时栈.栈空间.整数值 = IIf(条件a->数据值.是否相等(条件b->数据值), 1, 0)
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_jne
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            
            Dim 条件a As 对象类型 Ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 <> 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 <> 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 <> 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 <> 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 <> 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               临时栈.栈空间.整数值 = IIf(条件a->数据值.是否相等(条件b->数据值), 0, 1)
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            压入(栈 ,栈顶 ,临时栈)
         Case is_ja
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            Dim 条件a As 对象类型 Ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 > 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 > 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 > 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 > 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 > 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               'bug,无法比较
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_jae
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            
            Dim 条件a As 对象类型 Ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 >= 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 >= 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 >= 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 >= 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 >= 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               'bug,无法比较
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            压入(栈 ,栈顶 ,临时栈)
         Case is_jb
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            
            Dim 条件a As 对象类型 ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 < 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 < 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 < 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 < 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 < 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               'bug,无法比较
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            压入(栈 ,栈顶 ,临时栈)
         Case is_jbe
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:条件a
            '1:条件b
            
            Dim 条件a As 对象类型 Ptr
            Dim 条件b As 对象类型 Ptr
            
            条件a = 栈参数_0->转对象()
            条件b = 栈参数_1->转对象()
            
            临时栈.类型 = 栈_整数
            If 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 <= 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_文本 AndAlso 条件b->类型 = 类型_文本 Then
               临时栈.栈空间.整数值 = IIf(条件a->文本值 <= 条件b->文本值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 <= 条件b->小数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_小数 AndAlso 条件b->类型 = 类型_整数 Then
               临时栈.栈空间.整数值 = IIf(条件a->小数值 <= 条件b->整数值 ,1 ,0)
            ElseIf 条件a->类型 = 类型_整数 AndAlso 条件b->类型 = 类型_小数 Then
               临时栈.栈空间.整数值 = IIf(条件a->整数值 <= 条件b->小数值, 1, 0)
            ElseIf 条件a->类型 = 类型_数据 AndAlso 条件b->类型 = 类型_数据 Then
               'bug,无法比较
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 条件a->类型, 条件b->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_add
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 被操作数->整数值 + 操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               临时栈.类型   = 栈_文本
               临时栈.文本值 = 被操作数->文本值 + 操作数->文本值
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 + 操作数->小数值
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 + 操作数->整数值
            ElseIf 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->整数值 + 操作数->小数值
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               临时栈.类型   = 栈_数据
               被操作数->数据值.合并(@临时栈.数据值, 操作数->数据值)
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 被操作数->类型, 操作数->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_sub
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 被操作数->整数值 - 操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 - 操作数->小数值
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 - 操作数->整数值
            ElseIf 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->整数值 - 操作数->小数值
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               'bug，无法运算
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 被操作数->类型, 操作数->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_mul
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 被操作数->整数值 * 操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 * 操作数->小数值
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 * 操作数->整数值
            ElseIf 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->整数值 * 操作数->小数值
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               'bug，无法运算
               
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 被操作数->类型, 操作数->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_div
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 被操作数->整数值 / 操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 / 操作数->小数值
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 / 操作数->整数值
            ElseIf 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->整数值 / 操作数->小数值
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               'bug，无法运算
               
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 被操作数->类型, 操作数->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_mod
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 被操作数->整数值 Mod 操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 Mod 操作数->小数值
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->小数值 Mod 操作数->整数值
            ElseIf 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = 被操作数->整数值 Mod 操作数->小数值
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               'bug，无法运算
            Else
               Dim err_str As String = Space(256)
               sprintf(StrPtr(err_str), Err_运算过程发现类型不匹配, 被操作数->类型, 操作数->类型)
               FlyDebug(err_str, 现行指令索引)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_tcall
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            '0:返回值存储容器
            '1:启动地址
            '2:参数数量
            临时栈.类型 = 栈_整数
            
            Dim 参数数量 As LongInt = 栈参数_2->转对象()->整数值
            Dim 地址 As LongInt = 栈参数_1->转对象()->整数值
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  临时栈.栈空间.整数值 = 启动线程(基地址,模块索引,栈() ,栈顶 ,参数数量 ,栈参数_0->栈空间.容器值 ,地址)
               Case Else
                  临时栈.栈空间.整数值 = 启动线程(基地址, 模块索引, 栈(), 栈顶, 参数数量, 0, 地址)
            End Select
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_sleep
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 延时时间 As ULongInt = 栈参数_0->转对象()->整数值
            
            Sleep(延时时间)
         Case is_ret
            退出调用(调用栈(), 调用栈顶, 指令索引)
            
            If 指令索引 = -1 Then
               Exit While
            End If
            
         Case is_write
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Print 栈参数_0->转对象()->文本值;
         Case is_read
            临时栈.类型 = 栈_文本
            Line Input 临时栈.文本值
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_quit
            Exit While
         Case is_call
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            进入调用(调用栈(), 调用栈顶, 指令索引)
            
            Dim 地址 As ULongInt
            If 栈参数_0->类型 = 栈_地址 Then
               地址 = 栈参数_0->栈空间.地址
            ElseIf 栈参数_0->类型 = 栈_容器 Then
               If 栈参数_0->栈空间.容器值->对象->类型 = 类型_整数 Then
                  地址 = 栈参数_0->栈空间.容器值->对象->整数值
               End If
            ElseIf 栈参数_0->类型 = 栈_整数 Then
               地址 = 栈参数_0->栈空间.整数值
            End If
            
            指令索引 = 地址
         Case is_exit
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 返回值 As ULongInt
            
            If 栈参数_0->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            返回值 = 栈参数_0->转对象()->整数值
            
            结束工作(返回值)
            
            Return
         Case is_str
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 返回值 As String
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  Select Case As Const 栈参数_0->栈空间.容器值->对象->类型
                     Case 类型_整数
                        返回值 = Str(栈参数_0->栈空间.容器值->对象->整数值)
                     Case 类型_文本
                        返回值 = 栈参数_0->栈空间.容器值->对象->文本值
                     Case 类型_小数
                        返回值 = Str(栈参数_0->栈空间.容器值->对象->小数值)
                     Case 类型_数据
                        返回值 = Space(栈参数_0->栈空间.容器值->对象->数据值.取长度())
                        memcpy(StrPtr(返回值), 栈参数_0->栈空间.容器值->对象->数据值.取数据指针(), 栈参数_0->栈空间.容器值->对象->数据值.取长度())
                  End Select
               Case 栈_整数
                  返回值 = Str(栈参数_0->栈空间.整数值)
               Case 栈_文本
                  返回值 = 栈参数_0->文本值
               Case 栈_小数
                  返回值 = Str(栈参数_0->栈空间.小数值)
               Case 栈_地址
                  返回值 = Str(栈参数_0->栈空间.地址)
               Case 栈_数据
                  返回值 = Space(栈参数_0->数据值.取长度())
                  memcpy(StrPtr(返回值), 栈参数_0->数据值.取数据指针(), 栈参数_0->数据值.取长度())
            End Select
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = 返回值
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_msgbox
            栈参数_0 = @取栈参数_4_0(栈, 栈顶)
            栈参数_1 = @取栈参数_4_1(栈, 栈顶)
            栈参数_2 = @取栈参数_4_2(栈, 栈顶)
            栈参数_3 = @取栈参数_4_3(栈, 栈顶)
            栈顶 = 栈顶 - 4
            
            If 栈参数_0->取值类型() <> 类型_整数 OrElse 栈参数_3->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            Dim 窗口句柄 As hWnd
            窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = Cast(Integer ,MessageBoxA(窗口句柄 ,栈参数_1->转对象()->文本值 ,栈参数_2->转对象()->文本值 ,Cast(Integer ,栈参数_3->转对象()->整数值)))
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_stop
            暂停(栈() ,栈顶 ,调用栈() ,调用栈顶 ,调用栈(调用栈顶).容器())
         Case is_set
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->对象->定义(CPtr(is_set_type Ptr ,指令表(现行指令索引).数据)->类型)
            End If
            
            /'
         Case is_push_obj_this
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            If 栈参数_0->类型 = 栈_容器  Then
               临时栈.类型   = 栈_对象
               临时栈.栈空间.对象值 = 栈参数_0->栈空间.容器值->对象
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            '/'这条指令就用不着了，容器隐式转换到对象
            
         Case is_node
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 上限 As LongInt
            
            '0:容器
            '1:上限
            
            If 栈参数_1->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            上限 = 栈参数_1->转对象()->整数值
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->分配节(上限)
            End If
            
         Case is_bound
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            If 栈参数_0->类型 = 栈_容器 Then
               临时栈.类型 = 栈_整数
               临时栈.栈空间.整数值 = UBound(栈参数_0->栈空间.容器值->容器组)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_ptr
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:需要指向的 容器
            '1:需要存放指针的 容器
            If 栈参数_1->类型 = 栈_容器 Then
               If 栈参数_0->类型 = 栈_容器 Then
                  栈参数_1->栈空间.容器值->类型     = 容器类型_容器指针
                  栈参数_1->栈空间.容器值->容器指针 = 栈参数_0->栈空间.容器值
               End If
            End If
         Case is_set_box
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:需要设置的容器
            '1:需要设置的模型
            
            栈参数_0->栈空间.容器值->定义(栈参数_1->转对象()->整数值, 基地址,模块索引)
         Case is_jz
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            '0:地址
            '1:条件
            
            If 栈参数_1->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            Dim 地址 As ULongInt
            If 栈参数_0->类型 = 栈_地址 Then
               地址 = 栈参数_0->栈空间.地址
            ElseIf 栈参数_0->类型 = 栈_容器 Then
               If 栈参数_0->栈空间.容器值->对象->类型 = 类型_整数 Then
                  地址 = 栈参数_0->栈空间.容器值->对象->整数值
               End If
            ElseIf 栈参数_0->类型 = 栈_整数 Then
               地址 = 栈参数_0->栈空间.整数值
            End If
            
            If 栈参数_1->转对象()->整数值 = 0 Then
               指令索引 = 地址
            End If
         Case is_jnz
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            '0:地址
            '1:条件
            
            If 栈参数_1->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            Dim 地址 As ULongInt
            If 栈参数_0->类型 = 栈_地址 Then
               地址 = 栈参数_0->栈空间.地址
            ElseIf 栈参数_0->类型 = 栈_容器 Then
               If 栈参数_0->栈空间.容器值->对象->类型 = 类型_整数 Then
                  地址 = 栈参数_0->栈空间.容器值->对象->整数值
               End If
            ElseIf 栈参数_0->类型 = 栈_整数 Then
               地址 = 栈参数_0->栈空间.整数值
            End If
            
            If 栈参数_1->转对象()->整数值 <> 0 Then
               指令索引 = 地址
            End If
            
         Case is_and'只能计算整数，进行逻辑运算
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 1
               If 被操作数->整数值 = 0 OrElse 操作数->整数值 = 0 Then
                  临时栈.栈空间.整数值 = 0
               End If
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈 ,栈顶 ,临时栈)
         Case is_or'只能计算整数，进行逻辑运算
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 0
               If 被操作数->整数值 = 1 OrElse 操作数->整数值 = 1 Then
                  临时栈.栈空间.整数值 = 1
               End If
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_xor'只能计算整数，进行逻辑运算
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = 1
               If 被操作数->整数值 = 1 OrElse 操作数->整数值 = 1 Then
                  临时栈.栈空间.整数值 = 0
               ElseIf 被操作数->整数值 = 0 OrElse 操作数->整数值 = 0 Then
                  临时栈.栈空间.整数值 = 0
               End If
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_not'只能计算整数，进行逻辑运算
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = IIf(被操作数->整数值 = 1 ,0 ,1)
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_band
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = (被操作数->整数值 And 操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = (被操作数->小数值 And 操作数->小数值)
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               临时栈.类型 = 栈_数据
               被操作数->数据值.与(@临时栈.数据值, 操作数->数据值)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_bor
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = (被操作数->整数值 Or 操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = (被操作数->小数值 Or 操作数->小数值)
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               临时栈.类型 = 栈_数据
               被操作数->数据值.或(@临时栈.数据值, 操作数->数据值)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_bxor
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = (被操作数->整数值 Xor 操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = (被操作数->小数值 Xor 操作数->小数值)
               
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               临时栈.类型 = 栈_数据
               被操作数->数据值.异或(@临时栈.数据值, 操作数->数据值)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_bnot
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = Not 被操作数->整数值
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Not 被操作数->小数值
               
            ElseIf 被操作数->类型 = 类型_数据 Then
               临时栈.类型 = 栈_数据
               被操作数->数据值.非(@临时栈.数据值)
            End If
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_pop_box
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:需要弹出的值
            '1:需要存储的容器
            
            Dim 临时对象 As 对象类型
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  If 栈参数_1->栈空间.容器值 <> 栈参数_0->栈空间.容器值 Then
                     栈参数_1->栈空间.容器值->拷贝(栈参数_0->栈空间.容器值)
                  End If
               Case 栈_整数
                  栈参数_1->栈空间.容器值->对象->类型 = 类型_整数
                  栈参数_1->栈空间.容器值->对象->整数值 = 栈参数_0->栈空间.整数值
               Case 栈_文本
                  栈参数_1->栈空间.容器值->对象->类型 = 类型_文本
                  栈参数_1->栈空间.容器值->对象->文本值 = 栈参数_0->文本值
               Case 栈_小数
                  栈参数_1->栈空间.容器值->对象->类型 = 类型_小数
                  栈参数_1->栈空间.容器值->对象->小数值 = 栈参数_0->栈空间.小数值
               Case 栈_地址
                  栈参数_1->栈空间.容器值->对象->类型 = 类型_整数
                  栈参数_1->栈空间.容器值->对象->整数值 = 栈参数_0->栈空间.地址
               Case 栈_数据
                  栈参数_1->栈空间.容器值->对象->类型 = 类型_数据
                  栈参数_1->栈空间.容器值->对象->数据值 = 栈参数_0->数据值
            End Select
            
         Case is_wait
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            '0:句柄
            '1:等待时长
            
            WaitForSingleObject(Cast(Integer ,栈参数_0->转对象()->整数值) ,栈参数_1->转对象()->整数值)
            
         Case is_round
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            临时栈.类型 = 栈_小数
            临时栈.栈空间.小数值 = Val(Format(栈参数_0->转对象()->小数值 ,"0." & String(栈参数_1->转对象()->整数值 ,"0")))
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_left
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = Left(栈参数_0->转对象()->文本值 ,栈参数_1->转对象()->整数值)
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_right
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = Right(栈参数_0->转对象()->文本值 ,栈参数_1->转对象()->整数值)
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_mid
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = Mid(栈参数_0->转对象()->文本值 ,栈参数_1->转对象()->整数值 ,栈参数_2->转对象()->整数值)
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_InStr
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            Dim 起始位置 As Integer
            
            起始位置 = 栈参数_2->转对象()->整数值
            
            If 起始位置 <= 0 Then
               起始位置 = 1
            End If
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = InStr(起始位置 ,栈参数_0->转对象()->文本值 ,栈参数_1->转对象()->文本值)
            
            If 临时栈.栈空间.整数值 = 0 Then
               临时栈.栈空间.整数值 = -1
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_InStrRev
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            Dim 起始位置 As Integer
            Dim 源文本   As String
            起始位置 = 栈参数_2->转对象()->整数值
            源文本   = 栈参数_0->转对象()->文本值
            
            If 起始位置 > Len(源文本) Then
               起始位置 = Len(源文本)
            End If
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = InStrRev(源文本 ,栈参数_1->转对象->文本值 ,起始位置)
            
            If 临时栈.栈空间.整数值 = 0 Then
               临时栈.栈空间.整数值 = -1
            End If
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_UCase
            
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = UCase(栈参数_0->转对象->文本值)
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_LCase
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型   = 栈_文本
            临时栈.文本值 = LCase(栈参数_0->转对象->文本值)
            
            压入(栈 ,栈顶 ,临时栈)
         Case is_Len
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = Len(栈参数_0->转对象->文本值)
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_ValInt
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 返回值 As LongInt
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  Select Case As Const 栈参数_0->栈空间.容器值->对象->类型
                     Case 类型_整数
                        返回值 = 栈参数_0->栈空间.容器值->对象->整数值
                     Case 类型_文本
                        返回值 = ValLng(栈参数_0->栈空间.容器值->对象->文本值)
                     Case 类型_小数
                        返回值 = 栈参数_0->栈空间.容器值->对象->小数值
                     Case 类型_数据
                        memcpy(@返回值, 栈参数_0->栈空间.容器值->对象->数据值.取数据指针(), SizeOf(LongInt))
                  End Select
               Case 栈_整数
                  返回值 = 栈参数_0->栈空间.整数值
               Case 栈_文本
                  返回值 = ValLng(栈参数_0->文本值)
               Case 栈_小数
                  返回值 = 栈参数_0->栈空间.小数值
               Case 栈_地址
                  返回值 = 栈参数_0->栈空间.地址
               Case 栈_数据
                  memcpy(@返回值, 栈参数_0->数据值.取数据指针(), SizeOf(LongInt))
            End Select
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = 返回值
            压入(栈 ,栈顶 ,临时栈)
         Case is_ValDou
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 返回值 As Double
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  Select Case As Const 栈参数_0->栈空间.容器值->对象->类型
                     Case 类型_整数
                        返回值 = 栈参数_0->栈空间.容器值->对象->整数值
                     Case 类型_文本
                        返回值 = Val(栈参数_0->栈空间.容器值->对象->文本值)
                     Case 类型_小数
                        返回值 = 栈参数_0->栈空间.容器值->对象->小数值
                     Case 类型_数据
                        memcpy(@返回值, 栈参数_0->栈空间.容器值->对象->数据值.取数据指针(), SizeOf(Double))
                  End Select
               Case 栈_整数
                  返回值 = 栈参数_0->栈空间.整数值
               Case 栈_文本
                  返回值 = Val(栈参数_0->文本值)
               Case 栈_小数
                  返回值 = 栈参数_0->栈空间.小数值
               Case 栈_地址
                  返回值 = 栈参数_0->栈空间.地址
               Case 栈_数据
                  memcpy(@返回值, 栈参数_0->数据值.取数据指针(), SizeOf(Double))
            End Select
            临时栈.类型   = 栈_小数
            临时栈.栈空间.小数值 = 返回值
            压入(栈 ,栈顶 ,临时栈)
         Case is_LoadWindow
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            载入窗口(栈参数_0->转对象()->整数值, 基地址)
            
         Case is_GetQuitMsg
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = 离开消息
            
            压入(栈 ,栈顶 ,临时栈)
            
         Case is_PostQuitMsg
            
            离开消息 = 1
            PostQuitMessage(0)
            
         Case is_DoEvents
            
            While (离开消息 = 0)
               If 消息队列.Count() <> 0 Then
                  Dim 消息   As 消息类型 Ptr
                  Dim 索引   As Integer
                  Dim msg_ok As BOOL
                  
                  #ifdef __FB_64BIT__
                     消息 = Cast(消息类型 Ptr ,ValULng(消息队列.Dequeue()))
                  #else
                     消息 = Cast(消息类型 Ptr ,ValUInt(消息队列.Dequeue()))
                  #endif
                  
                  For i As Integer = 0 To UBound(窗口表)
                     If 窗口表(i).ID = 消息->ID Then
                        msg_ok = True
                        
                        Select Case As Const 消息->值
                           Case 窗口_事件_尺寸被改变
                              If 窗口表(i).事件_尺寸被改变 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_尺寸被改变
                              End If
                           Case 窗口_事件_将被销毁
                              If 窗口表(i).事件_将被销毁 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_将被销毁
                              End If
                           Case 窗口_事件_鼠标左键被按下
                              If 窗口表(i).事件_鼠标左键被按下 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_鼠标左键被按下
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                              End If
                           Case 窗口_事件_鼠标左键被放开
                              If 窗口表(i).事件_鼠标左键被放开 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_鼠标左键被放开
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                              End If
                           Case 窗口_事件_鼠标右键被按下
                              If 窗口表(i).事件_鼠标右键被按下 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_鼠标右键被按下
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                              End If
                           Case 窗口_事件_鼠标右键被放开
                              If 窗口表(i).事件_鼠标右键被放开 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_鼠标右键被放开
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                              End If
                           Case 窗口_事件_获取焦点
                              If 窗口表(i).事件_获取焦点 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_获取焦点
                              End If
                           Case 窗口_事件_失去焦点
                              If 窗口表(i).事件_失去焦点 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_失去焦点
                              End If
                           Case 窗口_事件_按下某键
                              If 窗口表(i).事件_按下某键 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_按下某键
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                              End If
                           Case 窗口_事件_放开某键
                              If 窗口表(i).事件_放开某键 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_放开某键
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                              End If
                           Case 窗口_事件_创建完毕
                              If 窗口表(i).事件_创建完毕 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_创建完毕
                              End If
                           Case 窗口_事件_被双击
                              If 窗口表(i).事件_被双击 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_被双击
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数1
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数2
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数3
                                 压入(栈 ,栈顶 ,临时栈)
                                 
                                 临时栈.类型   = 栈_整数
                                 临时栈.栈空间.整数值 = 消息->参数4
                                 压入(栈 ,栈顶 ,临时栈)
                              End If
                              
                           Case 窗口_事件_将被关闭
                              
                              If 窗口表(i).事件_将被关闭 <> 0 Then
                                 进入调用(调用栈() ,调用栈顶 ,指令索引)
                                 指令索引 = 窗口表(i).基地址 + 窗口表(i).事件_将被关闭
                              End If
                              
                        End Select
                        Delete 消息
                        Exit For
                     End If
                     
                     For j As Integer = 0 To UBound(窗口表(i).控件表)
                        If 窗口表(i).控件表(j).ID = 消息->ID Then
                           msg_ok = True
                           
                           Select Case As Const 窗口表(i).控件表(j).类型
                              Case 控件类型_按钮
                                 Select Case As Const 消息->值
                                    Case 按钮_事件_被单击
                                       If 窗口表(i).控件表(j).按钮值.事件_被单击 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).按钮值.事件_被单击
                                       End If
                                    Case 按钮_事件_获取焦点
                                       If 窗口表(i).控件表(j).按钮值.事件_获取焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).按钮值.事件_获取焦点
                                       End If
                                    Case 按钮_事件_失去焦点
                                       If 窗口表(i).控件表(j).按钮值.事件_失去焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).按钮值.事件_失去焦点
                                       End If
                                 End Select
                                 
                              Case 控件类型_编辑框
                                 
                                 Select Case As Const 消息->值
                                    Case 编辑框_事件_内容被改变
                                       If 窗口表(i).控件表(j).编辑框值.事件_内容被改变 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).编辑框值.事件_内容被改变
                                       End If
                                    Case 编辑框_事件_字符输入
                                       If 窗口表(i).控件表(j).编辑框值.事件_字符输入 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).编辑框值.事件_字符输入
                                       End If
                                    Case 编辑框_事件_获取焦点
                                       If 窗口表(i).控件表(j).编辑框值.事件_获取焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).编辑框值.事件_获取焦点
                                       End If
                                    Case 编辑框_事件_失去焦点
                                       If 窗口表(i).控件表(j).编辑框值.事件_失去焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).编辑框值.事件_失去焦点
                                       End If
                                 End Select
                                 
                              Case 控件类型_标签
                                 Select Case As Const 消息->值
                                    Case 标签_事件_被单击
                                       If 窗口表(i).控件表(j).标签值.事件_被单击 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).标签值.事件_被单击
                                       End If
                                    Case 标签_事件_被双击
                                       If 窗口表(i).控件表(j).标签值.事件_被单击 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).标签值.事件_被双击
                                       End If
                                       
                                       
                                 End Select
                                 
                              Case 控件类型_时钟
                                 Select Case As Const 消息->值
                                    Case 时钟_事件_周期事件
                                       If 窗口表(i).控件表(j).时钟值.事件_周期事件 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).时钟值.事件_周期事件
                                       End If
                                 End Select
                                 
                              Case 控件类型_选择框
                                 
                                 Select Case As Const 消息->值
                                    Case 选择框_事件_被单击
                                       If 窗口表(i).控件表(j).选择框值.事件_被单击 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).选择框值.事件_被单击
                                       End If
                                    Case 选择框_事件_获取焦点
                                       If 窗口表(i).控件表(j).选择框值.事件_获取焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).选择框值.事件_获取焦点
                                       End If
                                    Case 选择框_事件_失去焦点
                                       If 窗口表(i).控件表(j).选择框值.事件_失去焦点 <> 0 Then
                                          进入调用(调用栈() ,调用栈顶 ,指令索引)
                                          指令索引 = 窗口表(i).基地址 + 窗口表(i).控件表(j).选择框值.事件_失去焦点
                                       End If
                                 End Select
                                 
                           End Select
                           
                           Delete 消息
                           Exit For
                        End If
                     Next
                     
                     If msg_ok Then
                        Exit For
                     End If
                  Next
                  Exit While
               End If
               处理消息()
            Wend
            
         Case is_DestroyWindow
            Dim 窗口句柄 As hWnd
            窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
            
            If 窗口句柄 <> 0 Then
               DestroyWindow(窗口句柄)
            End If
            
         Case is_src
            
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Select Case As Const 栈参数_0->取值类型()
               Case 类型_整数
                  临时栈.类型   = 栈_整数
                  临时栈.栈空间.整数值 = 栈参数_0->转对象()->整数值
               Case 类型_文本
                  临时栈.类型   = 栈_文本
                  临时栈.文本值 = 栈参数_0->转对象->文本值
               Case 类型_小数
                  临时栈.类型   = 栈_小数
                  临时栈.栈空间.小数值 = 栈参数_0->转对象()->小数值
               Case 类型_数据
                  临时栈.类型 = 栈_数据
                  临时栈.数据值 = 栈参数_0->转对象()->数据值
            End Select
            
            压入(栈, 栈顶, 临时栈)
         Case is_next
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            '0:容器
            '1:容器组索引
            
            临时栈.类型 = 栈_容器
            临时栈.栈空间.容器值 = 栈参数_0->栈空间.容器值->容器组(栈参数_1->转对象()->整数值)
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_obj
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->重置() '重置为对象
            End If
         Case is_other
            
            Dim 序号 As LongInt
            
            
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            序号 = 栈参数_0->转对象()->整数值
            
            其他函数(序号, 栈(), 栈顶)
            
         Case is_join
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 加入成员数 As LongInt
            
            '0:容器
            '1:加入成员数
            
            加入成员数 = 栈参数_1->转对象()->整数值
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->加入节(加入成员数)
            End If
            
         Case is_del
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 删除成员数 As LongInt
            
            '0:容器
            '1:删除成员数
            
            删除成员数 = 栈参数_1->转对象()->整数值
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->删除节(删除成员数)
            End If
            
         Case is_data
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 返回值 As 数据
            
            Select Case As Const 栈参数_0->类型
               Case 栈_容器
                  Select Case As Const 栈参数_0->栈空间.容器值->对象->类型
                     Case 类型_整数
                        ReDim 返回值.数据空间(SizeOf(LongInt) -1)
                        memcpy(返回值.取数据指针(), @栈参数_0->栈空间.容器值->对象->m_整数值, SizeOf(LongInt))
                     Case 类型_文本
                        ReDim 返回值.数据空间(Len(栈参数_0->栈空间.容器值->对象->文本值)-1)
                        memcpy(返回值.取数据指针(), StrPtr(栈参数_0->栈空间.容器值->对象->文本值), Len(栈参数_0->栈空间.容器值->对象->文本值))
                     Case 类型_小数
                        ReDim 返回值.数据空间(SizeOf(Double) -1)
                        memcpy(返回值.取数据指针(), @栈参数_0->栈空间.容器值->对象->m_小数值, SizeOf(Double))
                     Case 类型_数据
                        返回值 = 栈参数_0->栈空间.容器值->对象->数据值
                  End Select
               Case 栈_整数
                  ReDim 返回值.数据空间(SizeOf(LongInt) -1)
                  memcpy(返回值.取数据指针(), @栈参数_0->栈空间.整数值, SizeOf(LongInt))
               Case 栈_文本
                  ReDim 返回值.数据空间(Len(栈参数_0->文本值)-1)
                  memcpy(返回值.取数据指针(), StrPtr(栈参数_0->文本值), Len(栈参数_0->文本值))
               Case 栈_小数
                  ReDim 返回值.数据空间(SizeOf(Double) -1)
                  memcpy(返回值.取数据指针(), @栈参数_0->栈空间.小数值, SizeOf(Double))
               Case 栈_地址
                  ReDim 返回值.数据空间(SizeOf(LongInt) -1)
                  memcpy(返回值.取数据指针(), @栈参数_0->栈空间.地址, SizeOf(LongInt))
               Case 栈_数据
                  返回值 = 栈参数_0->数据值
            End Select
            
            临时栈.类型   = 栈_数据
            临时栈.数据值 = 返回值
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_GetDataLen
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            If 栈参数_0->取值类型() <> 类型_数据 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 栈参数_0->取数据指针()->取长度()
            
            压入(栈, 栈顶, 临时栈)
         Case is_GetDataLeft
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            If 栈参数_0->取值类型() <> 类型_数据 OrElse 栈参数_1->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            临时栈.类型 = 栈_数据
            
            Dim 数据指针 As 数据 Ptr
            
            Dim 源长度 As Integer = 栈参数_0->取数据指针()->取长度()
            
            If 源长度 >= 栈参数_1->转对象()->整数值 Then
               临时栈.数据值.设长度(栈参数_1->转对象()->整数值)
               For i As Integer = 0 To 栈参数_1->转对象()->整数值-1
                  临时栈.数据值.数据空间(i) = 栈参数_0->取数据指针()->数据空间(i)
               Next
            Else
               临时栈.数据值.设长度(源长度)
               For i As Integer = 0 To 源长度-1
                  临时栈.数据值.数据空间(i) = 栈参数_0->取数据指针()->数据空间(i)
               Next
            End If
            压入(栈, 栈顶, 临时栈)
            
         Case is_GetDataRight
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            If 栈参数_0->取值类型() <> 类型_数据 OrElse 栈参数_1->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            临时栈.类型 = 栈_数据
            
            Dim 数据指针 As 数据 Ptr
            
            Dim 源长度 As Integer = 栈参数_0->取数据指针()->取长度()
            Dim index As Integer
            Dim data_len As Integer
            data_len = 栈参数_1->转对象()->整数值
            
            If data_len > 源长度 Then
               data_len = 源长度
            End If
            临时栈.数据值.设长度(data_len)
            For i As Integer = 源长度-data_len To 源长度-1
               临时栈.数据值.数据空间(index) = 栈参数_0->取数据指针()->数据空间(i)
               index = index + 1
            Next
            压入(栈, 栈顶, 临时栈)
         Case is_GetDataMid
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            If 栈参数_0->取值类型() <> 类型_数据 OrElse 栈参数_1->取值类型() <> 类型_整数 OrElse 栈参数_2->取值类型() <> 类型_整数 Then
               FlyDebug(Err_参数类型不匹配)
            End If
            
            Dim 源长度 As Integer = 栈参数_0->取数据指针()->取长度()
            
            临时栈.类型 = 栈_数据
            
            Dim copy_begin As Integer = 栈参数_1->转对象()->整数值
            Dim copy_end As Integer
            If copy_begin + 栈参数_2->转对象()->整数值 > 源长度 -1 Then
               copy_end = 源长度 -1
            Else
               copy_end = copy_begin + 栈参数_2->转对象()->整数值-1
            End If
            
            临时栈.数据值.设长度(copy_end - copy_begin+1)
            Dim index As Integer
            
            For i As Integer = copy_begin To copy_end
               临时栈.数据值.数据空间(index) = 栈参数_0->取数据指针()->数据空间(i)
               index = index + 1
            Next
            压入(栈, 栈顶, 临时栈)
            
         Case is_InData
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            Dim 数据指针 As 数据 Ptr
            Dim 数据指针2 As 数据 Ptr
            Dim 返回位置 As Integer = -1
            Dim index As Integer
            Dim find_ok As BOOL
            
            数据指针 = 栈参数_0->取数据指针()
            数据指针2 = 栈参数_1->取数据指针()
            
            index = 栈参数_2->转对象()->整数值
            
            While (True)
               If index + 数据指针2->取长度() + 1 > UBound(数据指针->数据空间) Then
                  Exit While
               End If
               find_ok = True
               For i As Integer = 0 To 数据指针2->取长度() -1
                  If 数据指针2->数据空间(i) <> 数据指针->数据空间(index + i) Then
                     find_ok = False
                     Exit For
                  End If
               Next
               If find_ok Then
                  返回位置 = index
                  Exit While
               End If
               index = index + 1
            Wend
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 返回位置
            
            压入(栈, 栈顶, 临时栈)
         Case is_InDataRev
            
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            Dim 数据指针 As 数据 Ptr
            Dim 数据指针2 As 数据 Ptr
            Dim 返回位置 As Integer = -1
            Dim index As Integer
            Dim find_ok As BOOL
            
            数据指针 = 栈参数_0->取数据指针()
            数据指针2 = 栈参数_1->取数据指针()
            
            index = 栈参数_2->转对象()->整数值
            
            If index < 0 OrElse index > UBound(数据指针->数据空间) Then
               index = UBound(数据指针->数据空间)
            End If
            
            While (True)
               find_ok = True
               For i As Integer = 0 To 数据指针2->取长度() -1
                  If 数据指针2->数据空间(i) <> 数据指针->数据空间(index + i) Then
                     find_ok = False
                     Exit For
                  End If
               Next
               If find_ok Then
                  返回位置 = index
                  Exit While
               End If
               index = index - 1
            Wend
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 返回位置
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_SetDataMid
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            Dim 数据指针 As 数据 Ptr
            Dim 数据指针2 As 数据 Ptr
            Dim copy_len As Integer
            数据指针 = 栈参数_0->取数据指针()
            数据指针2 = 栈参数_2->取数据指针()
            
            If 栈参数_1->转对象()->整数值 + 数据指针2->取长度() > 数据指针->取长度() Then
               copy_len = 数据指针2->取长度()*2-数据指针->取长度()
            Else
               copy_len = 数据指针2->取长度()
            End If
            
            memcpy(数据指针->取数据指针() + 栈参数_1->转对象()->整数值, 数据指针2->取数据指针(), copy_len)
            
         Case is_SpaceData
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_数据
            临时栈.数据值.设长度(栈参数_0->转对象()->整数值)
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_GetDataVal
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            Dim 数据指针 As 数据 Ptr
            
            数据指针 = 栈参数_0->取数据指针()
            临时栈.类型 = 栈_整数
            
            Select Case As Const 栈参数_1->转对象()->整数值
               Case 数据_字节
                  临时栈.栈空间.整数值 = *Cast(UByte Ptr, 数据指针->取数据指针())
               Case 数据_字
                  临时栈.栈空间.整数值 = *Cast(Short Ptr, 数据指针->取数据指针())
               Case 数据_双字
                  临时栈.栈空间.整数值 = *Cast(Long Ptr, 数据指针->取数据指针())
               Case 数据_四字
                  临时栈.栈空间.整数值 = *Cast(LongInt Ptr, 数据指针->取数据指针())
            End Select
            
            压入(栈, 栈顶, 临时栈)
         Case is_SetDataVal
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            Dim 值 As LongInt
            
            值 = 栈参数_0->转对象()->整数值
            
            临时栈.类型 = 栈_数据
            
            Select Case As Const 栈参数_1->转对象()->整数值
               Case 数据_字节
                  临时栈.数据值.设长度(SizeOf(UByte))
                  Poke UByte, 临时栈.取数据指针->取数据指针(), Cast(UByte, 值)
               Case 数据_字
                  临时栈.数据值.设长度(SizeOf(Short))
                  Poke Short,临时栈.取数据指针->取数据指针(), Cast(Short, 值)
               Case 数据_双字
                  临时栈.数据值.设长度(SizeOf(Long))
                  Poke Long,临时栈.取数据指针->取数据指针(), Cast(Long, 值)
               Case 数据_四字
                  临时栈.数据值.设长度(SizeOf(LongInt))
                  Poke LongInt,临时栈.取数据指针->取数据指针(), Cast(LongInt, 值)
            End Select
            
            压入(栈, 栈顶, 临时栈)
         Case is_ReadFile
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_数据
            
            Dim 路径 As String
            Dim 句柄 As HANDLE
            Dim inf As WIN32_FIND_DATAA
            Dim 长度 As LongInt
            
            路径 = 栈参数_0->转对象->文本值
            
            句柄 = CreateFileA(路径, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0)
            If 句柄 = -1 Then
               临时栈.数据值.设长度(0)
            Else
               If FindFirstFileA(路径, @inf) <> -1 Then
                  长度 = (inf.nFileSizeHigh Shl 32) Or inf.nFileSizeLow
                  临时栈.数据值.设长度(长度)
                  Dim NumberOfBytesWritten As DWORD
                  ReadFile(句柄, 临时栈.数据值.取数据指针(), 长度, @NumberOfBytesWritten, 0)
               End If
               CloseHandle(句柄)
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_WriteFile
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            Dim 路径 As String
            Dim 句柄 As HANDLE
            Dim 数据指针 As 数据 Ptr
            路径 = 栈参数_0->转对象->文本值
            
            数据指针 = 栈参数_1->取数据指针()
            
            句柄 = CreateFileA(路径, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, 0)
            
            临时栈.类型 = 栈_整数
            
            If 句柄 = -1 Then
               临时栈.栈空间.整数值 = 0
            Else
               Dim NumberOfBytesWritten As DWORD
               临时栈.栈空间.整数值 =IIf(WriteFile(句柄, 数据指针->取数据指针(), 数据指针->取长度(), @NumberOfBytesWritten, 0),1,0)
               CloseHandle(句柄)
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_MkDir
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = iif(CreateDirectoryA(栈参数_0->转对象->文本值, 0),1,0)
            
            压入(栈, 栈顶, 临时栈)
         Case is_RmDir
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = IIf(yf_KillDir(StringToCWSTR(栈参数_0->转对象->文本值)),1,0)
            
            压入(栈, 栈顶, 临时栈)
         Case is_FileCopy
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = IIf(CopyFileA(栈参数_0->转对象->文本值, 栈参数_1->转对象->文本值, 0),1,0)
            压入(栈, 栈顶, 临时栈)
         Case is_FileMove
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = IIf(MoveFileA(栈参数_0->转对象->文本值, 栈参数_1->转对象->文本值), 1, 0)
            压入(栈, 栈顶, 临时栈)
         Case is_FileKill
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 =IIf(DeleteFileA(栈参数_0->转对象->文本值),1,0)
            压入(栈, 栈顶, 临时栈)
         Case is_FileName
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = IIf(Name(栈参数_0->转对象->文本值, 栈参数_1->转对象->文本值), 1, 0)
            压入(栈, 栈顶, 临时栈)
         Case is_GetLoadDir
            临时栈.类型 = 栈_文本
            临时栈.文本值 = 装载目录
            压入(栈, 栈顶, 临时栈)
         Case is_GetLoadName
            临时栈.类型 = 栈_文本
            临时栈.文本值 = 装载文件名
            压入(栈, 栈顶, 临时栈)
         Case is_TerminateThread
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            TerminateThread(Cast(Integer, 栈参数_0->转对象()->整数值), 0)
            
         Case is_ResumeThread
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            ResumeThread(Cast(Integer, 栈参数_0->转对象()->整数值))
         Case is_SuspendThread
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            SuspendThread(Cast(Integer, 栈参数_0->转对象()->整数值))
            
         Case is_InitializeCriticalSection
            Dim temp As CRITICAL_SECTION Ptr = Allocate(SizeOf(CRITICAL_SECTION))
            InitializeCriticalSection(temp)
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = Cast(Integer, temp)
            
            压入(栈, 栈顶, 临时栈)
         Case is_DeleteCriticalSection
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            DeleteCriticalSection(Cast(Integer, 栈参数_0->转对象()->整数值))
            Deallocate(Cast(Integer, 栈参数_0->转对象()->整数值))
         Case is_EnterCriticalSection
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            EnterCriticalSection(Cast(Integer, 栈参数_0->转对象()->整数值))
         Case is_LeaveCriticalSection
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            LeaveCriticalSection(Cast(Integer, 栈参数_0->转对象()->整数值))
         Case is_Launch
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            加载模块(栈参数_0->转对象->文本值 + ".fly_pak")
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 取模块基地址_相对(栈参数_0->转对象->文本值+ ".fly_pak")
            
            If 临时栈.栈空间.整数值 <> -1 Then
               Dim 空栈() As 栈类型
               Dim 线程句柄 As HANDLE
               Dim 线程ID As DWORD
               Dim 返回容器 As 容器类型
               返回容器.重置()
               
               部署线程(临时栈.栈空间.整数值,取模块索引_相对(栈参数_0->转对象->文本值+ ".fly_pak"), 空栈(), 0, 线程句柄, 线程ID, @返回容器)
               
               WaitForSingleObject(线程句柄, -1)
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_GetPack
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 取模块基地址_相对(栈参数_0->转对象->文本值 + ".fly_pak")
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_GetPackExport
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 取导出地址(栈参数_0->转对象()->整数值, 栈参数_1->转对象->文本值)
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_IsFileExist
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 路径 As String
            Dim FindData As WIN32_FIND_DATAA
            Dim hFind As HANDLE
            路径 = 栈参数_0->转对象->文本值
            
            hFind=FindFirstFileA(路径,@FindData)
            临时栈.类型 = 栈_整数
            
            If hFind = INVALID_HANDLE_VALUE Then
               临时栈.栈空间.整数值 = 0
            Else
               临时栈.栈空间.整数值 = IIf((FindData.dwFileAttributes And FILE_ATTRIBUTE_DIRECTORY) = 0, 1, 0)
            End If
            FindClose(hFind)
            
            压入(栈, 栈顶, 临时栈)
         Case is_IsObj
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            临时栈.类型 = 栈_整数
            If 栈参数_0->类型 = 栈_容器 Then
               临时栈.栈空间.整数值 = IIf(栈参数_0->类型 = 容器类型_值 AndAlso 栈参数_0->栈空间.容器值->对象<>0 , 1, 0)
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_sgn
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = Sgn(被操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Sgn(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_abs
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = Abs(被操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Abs(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
            
         Case is_int
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = Int(被操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Int(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_fix
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               临时栈.类型   = 栈_整数
               临时栈.栈空间.整数值 = Fix(被操作数->整数值)
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Fix(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_pow
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim 被操作数 As 对象类型 Ptr
            Dim 操作数   As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            操作数 = 栈参数_1->转对象()
            
            If 被操作数->类型 = 类型_整数 AndAlso 操作数->类型 = 类型_整数 Then
               临时栈.类型 = 栈_小数
               临时栈.栈空间.小数值 = (被操作数->小数值 ^ 操作数->小数值)
            ElseIf 被操作数->类型 = 类型_文本 AndAlso 操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 AndAlso 操作数->类型 = 类型_小数 Then
               临时栈.类型 = 栈_小数
               临时栈.栈空间.小数值 = (被操作数->小数值 ^ 操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 AndAlso 操作数->类型 = 类型_数据 Then
               
            End If
            
            压入(栈, 栈顶, 临时栈)
         Case is_sqr
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Sqr(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_sin
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Sin(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_cos
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Cos(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         case is_tan
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Tan(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_atn
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Atn(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_log
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Log(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_exp
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            Dim 被操作数 As 对象类型 Ptr
            
            被操作数 = 栈参数_0->转对象()
            
            If 被操作数->类型 = 类型_整数 Then
               
            ElseIf 被操作数->类型 = 类型_文本 Then
               
            ElseIf 被操作数->类型 = 类型_小数 Then
               临时栈.类型   = 栈_小数
               临时栈.栈空间.小数值 = Exp(被操作数->小数值)
            ElseIf 被操作数->类型 = 类型_数据 Then
               
            End If
            压入(栈, 栈顶, 临时栈)
         Case is_randomize
            
            Randomize
            
         Case is_rnd
            
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 - 2
            
            Dim first_obj As 对象类型 Ptr
            Dim last_obj As 对象类型 Ptr
            Dim first As Double
            Dim last As Double
            
            first_obj = 栈参数_0->转对象()
            last_obj = 栈参数_1->转对象()
            
            first = first_obj->小数值
            last = last_obj->小数值
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = Rnd * (last - first) + first
            压入(栈, 栈顶, 临时栈)
         Case is_GetTickCount
            
            临时栈.类型   = 栈_整数
            临时栈.栈空间.整数值 = GetTickCount()
            压入(栈, 栈顶, 临时栈)
            
         Case is_loop
            栈参数_0 = @取栈参数_4_0(栈, 栈顶)
            栈参数_1 = @取栈参数_4_1(栈, 栈顶)
            栈参数_2 = @取栈参数_4_2(栈, 栈顶)
            栈参数_3 = @取栈参数_4_3(栈, 栈顶)
            栈顶 = 栈顶 - 4
            
            Dim 循环栈顶 As Integer Ptr = @调用栈(调用栈顶).循环栈顶
            
            *循环栈顶 = *循环栈顶 + 1
            调用栈(调用栈顶).循环栈(*循环栈顶).循环位置 = 栈参数_0->转对象()->整数值
            调用栈(调用栈顶).循环栈(*循环栈顶).循环次数 = 栈参数_2->转对象()->整数值
            调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象 = 栈参数_3->栈空间.容器值->对象
            
            调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象->整数值 = 0
            
            If 栈参数_2->转对象()->整数值 <= 0 Then
               指令索引 = 栈参数_1->转对象()->整数值
            End If
         Case is_loop_up
            Dim 循环栈顶 As Integer Ptr = @调用栈(调用栈顶).循环栈顶
            
            调用栈(调用栈顶).循环栈(*循环栈顶).循环次数 = 调用栈(调用栈顶).循环栈(*循环栈顶).循环次数 -1
            
            If 调用栈(调用栈顶).循环栈(*循环栈顶).循环次数 > 0 Then
               If 调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象 <> 0 Then
                  调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象->整数值 = 调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象->整数值 + 1
               End If
               指令索引 = 调用栈(调用栈顶).循环栈(*循环栈顶).循环位置
            End If
            
         Case is_loop_pure
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            If 栈参数_2->转对象()->整数值 > 0 Then
               Dim 循环栈顶 As Integer Ptr = @调用栈(调用栈顶).循环栈顶
               
               *循环栈顶 = *循环栈顶 + 1
               调用栈(调用栈顶).循环栈(*循环栈顶).循环位置 = 栈参数_0->转对象()->整数值
               调用栈(调用栈顶).循环栈(*循环栈顶).循环次数 = 栈参数_2->转对象()->整数值
               调用栈(调用栈顶).循环栈(*循环栈顶).循环存储对象 = 0
            Else
               指令索引 = 栈参数_1->转对象()->整数值
            End If
         Case is_insert
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            '0:容器
            '1:位置
            '2:成员数
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->加入指定节(栈参数_1->转对象()->整数值,栈参数_2->转对象()->整数值)
            End If
            
         Case is_remove
            
            栈参数_0 = @取栈参数_3_0(栈, 栈顶)
            栈参数_1 = @取栈参数_3_1(栈, 栈顶)
            栈参数_2 = @取栈参数_3_2(栈, 栈顶)
            栈顶 = 栈顶 - 3
            
            '0:容器
            '1:位置
            '2:成员数
            
            If 栈参数_0->类型 = 栈_容器 Then
               栈参数_0->栈空间.容器值->删除指定节(栈参数_1->转对象()->整数值,栈参数_2->转对象()->整数值)
            End If
            
         Case is_LoadLib
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            加载库(栈参数_0->转对象->文本值+ ".fly_lib")
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = Cast(Integer, 取库句柄_相对(栈参数_0->转对象->文本值 + ".fly_lib"))
            
            压入(栈, 栈顶, 临时栈)
         Case is_FreeLib
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            释放库(Cast(Integer,栈参数_0->转对象->整数值))
            
         Case is_GetLibFunc
            栈参数_0 = @取栈参数_2_0(栈, 栈顶)
            栈参数_1 = @取栈参数_2_1(栈, 栈顶)
            栈顶 = 栈顶 -2
            
            临时栈.类型 = 栈_整数
            临时栈.栈空间.整数值 = 取引用地址(Cast(Integer,栈参数_0->转对象()->整数值), 栈参数_1->转对象->文本值)
            
            压入(栈, 栈顶, 临时栈)
            
         Case is_CallLib
            栈参数_0 = @取栈参数_1_0(栈, 栈顶)
            栈顶 = 栈顶 -1
            
            调用库(栈(), 栈顶, Cast(Integer, 栈参数_0->转对象->整数值))
            
         Case is_loop_pop
            调用栈(调用栈顶).循环栈顶 = 调用栈(调用栈顶).循环栈顶 -1
         Case is_for
            栈参数_0 = @取栈参数_6_0(栈, 栈顶)
            栈参数_1 = @取栈参数_6_1(栈, 栈顶)
            栈参数_2 = @取栈参数_6_2(栈, 栈顶)
            栈参数_3 = @取栈参数_6_3(栈, 栈顶)
            栈参数_4 = @取栈参数_6_4(栈, 栈顶)
            栈参数_5 = @取栈参数_6_5(栈, 栈顶)
            栈顶 = 栈顶 - 6
            
            Dim 变量循环栈顶 As Integer Ptr = @调用栈(调用栈顶).变量循环栈顶
            *变量循环栈顶 = *变量循环栈顶 + 1
            调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环位置 = 栈参数_0->转对象()->整数值
            调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环目标值 = 栈参数_3->转对象()->整数值
            调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环步长 = 栈参数_4->转对象()->整数值
            调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环存储对象 = 栈参数_5->栈空间.容器值->对象
            调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环存储对象->整数值 = 栈参数_2->转对象()->整数值
            
            If 栈参数_4->转对象()->整数值 > 0 Then
               If 栈参数_2->转对象()->整数值 > 栈参数_3->转对象()->整数值 Then
                  指令索引 = 栈参数_1->转对象()->整数值
               End If
               
            ElseIf 栈参数_4->转对象()->整数值 < 0 Then
               If 栈参数_3->转对象()->整数值 > 栈参数_2->转对象()->整数值 Then
                  指令索引 = 栈参数_1->转对象()->整数值
               End If
            End If
            
         Case is_for_up
            Dim 变量循环栈顶 As Integer Ptr = @调用栈(调用栈顶).变量循环栈顶
            If 调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环存储对象->整数值 <> 调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环目标值 Then
               调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环存储对象->整数值 = 调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环存储对象->整数值 + 调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环步长
               指令索引 = 调用栈(调用栈顶).变量循环栈(*变量循环栈顶).循环位置
            End If
         Case is_for_pop
            调用栈(调用栈顶).变量循环栈顶 = 调用栈(调用栈顶).变量循环栈顶 -1
         Case Else
            FlyDebug("未知指令:" + Str(指令表(现行指令索引).指令) ,现行指令索引)
      End Select
      临时栈.清空()
   Wend
   'Function = 寄存器(RR)
   If GetCurrentThreadId() = 主线程ID Then
      结束所有线程()
   End If
   
   
   If 栈顶 <> 0 Then
      栈参数_0 = @取栈参数_1_0(栈, 栈顶)
      栈顶 = 栈顶 -1
   Else
      
   End If
   
   If 不进行任何返回 = False Then
      Select Case As Const 栈参数_0->类型
         Case 栈_容器
            返回值地址_容器->拷贝(栈参数_0->栈空间.容器值)
         Case 栈_整数
            返回值地址_容器->对象->类型 = 类型_整数
            返回值地址_容器->对象->整数值 = 栈参数_0->栈空间.整数值
         Case 栈_文本
            返回值地址_容器->对象->类型 = 类型_文本
            返回值地址_容器->对象->文本值 = 栈参数_0->文本值
         Case 栈_小数
            返回值地址_容器->对象->类型 = 类型_小数
            返回值地址_容器->对象->小数值 = 栈参数_0->栈空间.小数值
         Case 栈_地址
            返回值地址_容器->对象->类型 = 类型_整数
            返回值地址_容器->对象->整数值 = 栈参数_0->栈空间.地址
      End Select
   End If
End Sub

Sub 其他函数(序号 As LongInt,栈() As 栈类型 ,ByRef 栈顶 As Integer)
   Dim 栈参数_0 As 栈类型 Ptr
   Dim 栈参数_1 As 栈类型 Ptr
   Dim 栈参数_2 As 栈类型 Ptr
   Dim 栈参数_3 As 栈类型 Ptr
   Dim 栈参数_4 As 栈类型 Ptr
   
   Dim 临时栈 As 栈类型
   Select Case As Const 序号
      Case 0 '窗口_置可视
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 - 2
         
         Dim 句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         If 句柄 <> 0 Then
            ShowWindow(句柄 ,IIf(栈参数_1->转对象()->整数值 = 1 ,SW_SHOW ,SW_HIDE))
         End If
         
         '保存状态
         窗口索引 = ID取窗口索引(栈参数_0->转对象()->整数值)
         If 窗口索引 <> -1 Then
            窗口表(窗口索引).可视 = (栈参数_1->转对象()->整数值 = 1)
            Return
         End If
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            Select Case 窗口表(窗口索引).控件表(控件索引).类型
               Case 控件类型_按钮
                  窗口表(窗口索引).控件表(控件索引).按钮值.可视 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_编辑框
                  窗口表(窗口索引).控件表(控件索引).编辑框值.可视 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_标签
                  窗口表(窗口索引).控件表(控件索引).标签值.可视 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_图片框
                  窗口表(窗口索引).控件表(控件索引).图片框值.可视 = (栈参数_1->转对象()->整数值 = 1)
            End Select
         End If
         
      Case 1 '窗口_置禁止
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 - 2
         
         Dim 句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         句柄=ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         If 句柄 <> 0 Then
            EnableWindow(句柄 ,IIf(栈参数_1->转对象()->整数值 = 1 ,0 ,1))
         End If
         
         '保存状态
         窗口索引 = ID取窗口索引(栈参数_0->转对象()->整数值)
         If 窗口索引 <> -1 Then
            窗口表(窗口索引).禁止 = (栈参数_1->转对象()->整数值 = 1)
            Return
         End If
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            Select Case 窗口表(窗口索引).控件表(控件索引).类型
               Case 控件类型_按钮
                  窗口表(窗口索引).控件表(控件索引).按钮值.禁止 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_编辑框
                  窗口表(窗口索引).控件表(控件索引).编辑框值.禁止 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_标签
                  窗口表(窗口索引).控件表(控件索引).标签值.禁止 = (栈参数_1->转对象()->整数值 = 1)
               Case 控件类型_图片框
                  窗口表(窗口索引).控件表(控件索引).图片框值.禁止 = (栈参数_1->转对象()->整数值 = 1)
            End Select
         End If
         
      Case 2 '窗口_置标题
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 - 2
         
         Dim 句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         If 句柄 <> 0 Then
            SetWindowTextA(句柄 ,栈参数_1->转对象->文本值)
         End If
         
         '保存状态
         窗口索引 = ID取窗口索引(栈参数_0->转对象()->整数值)
         If 窗口索引 <> -1 Then
            窗口表(窗口索引).标题 = 栈参数_1->转对象->文本值
            Return
         End If
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            Select Case As Const 窗口表(窗口索引).控件表(控件索引).类型
               Case 控件类型_按钮
                  窗口表(窗口索引).控件表(控件索引).按钮值.标题 = 栈参数_1->转对象->文本值
               Case 控件类型_编辑框
                  窗口表(窗口索引).控件表(控件索引).编辑框值.内容 = 栈参数_1->转对象->文本值
               Case 控件类型_标签
                  窗口表(窗口索引).控件表(控件索引).标签值.标题 = 栈参数_1->转对象->文本值
            End Select
         End If
         
      Case 3 '窗口_取可视
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 句柄 As hWnd
         句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 0
         If 句柄 <> 0 Then
            临时栈.栈空间.整数值 = IIf(IsWindowVisible(句柄) <> 0 ,1 ,0)
         End If
         
         压入(栈 ,栈顶 ,临时栈)
      Case 4 '窗口_取禁止
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 0
         
         窗口索引 = ID取窗口索引(栈参数_0->转对象()->整数值)
         If 窗口索引 <> -1 Then
            临时栈.栈空间.整数值 = IIf(窗口表(窗口索引).禁止 ,1 ,0)
            压入(栈 ,栈顶 ,临时栈)
            Return
         End If
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            Select Case 窗口表(窗口索引).控件表(控件索引).类型
               Case 控件类型_按钮
                  临时栈.栈空间.整数值 = IIf(窗口表(窗口索引).控件表(控件索引).按钮值.禁止,1,0)
               Case 控件类型_编辑框
                  临时栈.栈空间.整数值 = IIf(窗口表(窗口索引).控件表(控件索引).编辑框值.禁止,1,0)
               Case 控件类型_标签
                  临时栈.栈空间.整数值 =IIf( 窗口表(窗口索引).控件表(控件索引).标签值.禁止,1,0)
               Case 控件类型_图片框
                  临时栈.栈空间.整数值 = IIf(窗口表(窗口索引).控件表(控件索引).图片框值.禁止,1,0)
            End Select
         End If
         压入(栈 ,栈顶 ,临时栈)
      Case 5 '窗口_取标题
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         临时栈.类型 = 栈_文本
         临时栈.文本值 = ""
         
         If 窗口句柄 <> 0 Then
            Dim l_len As Long = GetWindowTextLengthA(窗口句柄)
            临时栈.文本值 = Space(l_len)
            GetWindowTextA(窗口句柄 ,StrPtr(临时栈.文本值) ,l_len+1)
         End If
         
         压入(栈 ,栈顶 ,临时栈)
         
      Case 6 '窗口_是否已创建
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = IsWindow(窗口句柄)
         
         压入(栈 ,栈顶 ,临时栈)
      Case 7 '窗口_移动
         栈参数_0 = @取栈参数_5_0(栈, 栈顶)
         栈参数_1 = @取栈参数_5_1(栈, 栈顶)
         栈参数_2 = @取栈参数_5_2(栈, 栈顶)
         栈参数_3 = @取栈参数_5_3(栈, 栈顶)
         栈参数_4 = @取栈参数_5_4(栈, 栈顶)
         栈顶 = 栈顶 - 5
         
         Dim 窗口句柄 As hWnd
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         MoveWindow(窗口句柄 ,Cast(Integer ,栈参数_1->转对象()->整数值) ,Cast(Integer ,栈参数_2->转对象()->整数值) ,Cast(Integer ,栈参数_3->转对象()->整数值) ,Cast(Integer ,栈参数_4->转对象()->整数值) ,1)
      Case 8 '编辑框_置只读
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 - 2
         
         Dim 窗口句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_编辑框 Then
               SendMessage(窗口句柄 ,EM_SETREADONLY ,IIf(栈参数_1->转对象()->整数值 = 1 ,1 ,0) ,0)
               
               窗口表(窗口索引).控件表(控件索引).编辑框值.只读 = (栈参数_1->转对象()->整数值 = 1)
            End If
         End If
         
      Case 9 '编辑框_取只读
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         临时栈.类型 = 栈_整数 
         
         临时栈.栈空间.整数值 = 0
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_编辑框 Then
               临时栈.栈空间.整数值 = IIf(窗口表(窗口索引).控件表(控件索引).编辑框值.只读 ,1 ,0)
            End If
         End If
         
         压入(栈, 栈顶, 临时栈)
         
      Case 10 '窗口_取左边
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 局_位置和大小.Left
         
         压入(栈, 栈顶, 临时栈)
      Case 11 '窗口_取顶边
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 局_位置和大小.top
         
         压入(栈, 栈顶, 临时栈)
      Case 12'窗口_取宽度
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 局_位置和大小.Right - 局_位置和大小.Left
         
         压入(栈, 栈顶, 临时栈)
      Case 13'窗口_取高度
         
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = 局_位置和大小.bottom - 局_位置和大小.top
         
         压入(栈, 栈顶, 临时栈)
         
      case 14 '窗口_取用户区左边
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim pwi As WINDOWINFO
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         pwi.cbSize = SizeOf(pwi)
         GetWindowInfo(窗口句柄, @pwi)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = pwi.rcClient.left
         
         压入(栈, 栈顶, 临时栈)
         
      Case 15 '窗口_取用户区顶边
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim pwi As WINDOWINFO
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         pwi.cbSize = SizeOf(pwi)
         GetWindowInfo(窗口句柄, @pwi)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = pwi.rcClient.top
         
         压入(栈, 栈顶, 临时栈)
         
      Case 16 '窗口_取用户区宽度
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim pwi As WINDOWINFO
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         pwi.cbSize = SizeOf(pwi)
         GetWindowInfo(窗口句柄, @pwi)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = pwi.rcClient.Right - pwi.rcClient.Left
         
         压入(栈, 栈顶, 临时栈)
      Case 17 '窗口_取用户区高度
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         Dim pwi As WINDOWINFO
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         pwi.cbSize = SizeOf(pwi)
         GetWindowInfo(窗口句柄, @pwi)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = pwi.rcClient.bottom - pwi.rcClient.top
         
         压入(栈, 栈顶, 临时栈)
         
      Case 18 '窗口_置左边
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         MoveWindow(窗口句柄, 栈参数_1->转对象()->整数值, 局_位置和大小.top, 局_位置和大小.Right - 局_位置和大小.Left, 局_位置和大小.bottom - 局_位置和大小.top, 1)
         
      Case 19 '窗口_置顶边
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         MoveWindow(窗口句柄, 局_位置和大小.Left, 栈参数_1->转对象()->整数值, 局_位置和大小.Right - 局_位置和大小.Left, 局_位置和大小.bottom - 局_位置和大小.top, 1)
         
      Case 20 '窗口_置宽度
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         MoveWindow(窗口句柄, 局_位置和大小.Left, 局_位置和大小.top, 栈参数_1->转对象()->整数值, 局_位置和大小.bottom - 局_位置和大小.top, 1)
         
      Case 21 '窗口_置高度
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         
         Dim 窗口句柄 As hWnd
         Dim 局_位置和大小 As Rect
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         GetWindowRect(窗口句柄, @局_位置和大小)
         
         MoveWindow(窗口句柄, 局_位置和大小.Left, 局_位置和大小.top, 局_位置和大小.Right - 局_位置和大小.Left, 栈参数_1->转对象()->整数值, 1)
         
      Case 22 '时钟_置时钟周期
         
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         
         
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_时钟 Then
               窗口表(窗口索引).控件表(控件索引).时钟值.时钟周期 = 栈参数_1->转对象()->整数值
               If 窗口表(窗口索引).控件表(控件索引).时钟值.时钟周期 = 0 Then
                  KillTimer(窗口表(窗口索引).成员_控件句柄, 窗口表(窗口索引).控件表(控件索引).ID)
               Else
                  SetTimer(窗口表(窗口索引).成员_控件句柄, 窗口表(窗口索引).控件表(控件索引).ID, 窗口表(窗口索引).控件表(控件索引).时钟值.时钟周期, 0)
               End If
            End If
         End If
      Case 23 '时钟_取时钟周期
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         临时栈.类型 = 栈_整数 
         
         临时栈.栈空间.整数值 = 0
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_时钟 Then
               临时栈.栈空间.整数值 = 窗口表(窗口索引).控件表(控件索引).时钟值.时钟周期
            End If
         End If
         
         压入(栈, 栈顶, 临时栈)
         
      Case 24 '图片框_置图片
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         Dim 窗口句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_图片框 Then
               窗口表(窗口索引).控件表(控件索引).图片框值.图片_ReDim(栈参数_1->转对象()->数据值.取长度() -1)
               
               If 栈参数_1->转对象()->数据值.取长度() <> 0 Then
                  memcpy(@窗口表(窗口索引).控件表(控件索引).图片框值.图片(0), 栈参数_1->转对象()->数据值.取数据指针(), 栈参数_1->转对象()->数据值.取长度())
               End If
               DeleteObject(窗口表(窗口索引).控件表(控件索引).图片框值.位图句柄)
               
               窗口表(窗口索引).控件表(控件索引).图片框值.位图句柄 = 图片转位图(窗口表(窗口索引).控件表(控件索引).图片框值.图片())
               
               SendMessage(窗口句柄, STM_SETIMAGE, IMAGE_BITMAP, 窗口表(窗口索引).控件表(控件索引).图片框值.位图句柄)
               
            End If
         End If
         
      Case 25 '图片框_取图片
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         临时栈.类型 = 栈_数据
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_图片框 Then
               临时栈.数据值.设长度(ARRAYSIZE(窗口表(窗口索引).控件表(控件索引).图片框值.图片))
               If ARRAYSIZE(窗口表(窗口索引).控件表(控件索引).图片框值.图片) <> 0 Then
                  memcpy(@临时栈.数据值.数据空间(0),@窗口表(窗口索引).控件表(控件索引).图片框值.图片(0),ARRAYSIZE(窗口表(窗口索引).控件表(控件索引).图片框值.图片))
               End If
            End If
         End If
         
         压入(栈, 栈顶, 临时栈)
         
      Case 26 '选择框_置状态
         栈参数_0 = @取栈参数_2_0(栈, 栈顶)
         栈参数_1 = @取栈参数_2_1(栈, 栈顶)
         栈顶 = 栈顶 -2
         Dim 窗口句柄 As hWnd
         Dim 窗口索引 As Integer
         Dim 控件索引 As Integer
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         ID取控件索引(栈参数_0->转对象()->整数值 ,窗口索引 ,控件索引)
         
         If 窗口索引 <> -1 AndAlso 控件索引 <> -1 Then
            If 窗口表(窗口索引).控件表(控件索引).类型 = 控件类型_选择框 Then
               窗口表(窗口索引).控件表(控件索引).选择框值.状态 = 栈参数_1->转对象()->整数值
               SendMessage(窗口句柄, BM_SETCHECK, 窗口表(窗口索引).控件表(控件索引).选择框值.状态, 0)
            End If
         End If
         
      Case 27 '选择框_取状态
         
         栈参数_0 = @取栈参数_1_0(栈, 栈顶)
         栈顶 = 栈顶 -1
         
         Dim 窗口句柄 As hWnd
         
         窗口句柄 = ID取窗口句柄(栈参数_0->转对象()->整数值)
         
         临时栈.类型 = 栈_整数
         临时栈.栈空间.整数值 = SendMessage(窗口句柄, BM_GETCHECK, 0, 0)
         
         压入(栈, 栈顶, 临时栈)
   End Select
End Sub

Sub 结束工作(返回值 As LongInt)
   EnterCriticalSection(@临界资源_线程表)
   
   If UBound(线程表)-LBound(线程表)+1 <> 0 Then
      For i As Integer = LBound(线程表) To UBound(线程表)
         If 线程表(i).线程ID = GetCurrentThreadId() Then
            Continue For
         End If
         If 线程表(i).线程ID = 主线程ID Then
            Continue For
         End If
         TerminateThread(线程表(i).线程句柄 ,0)
      Next
   End If
   
   LeaveCriticalSection(@临界资源_线程表)
   
   主线程返回值地址->对象->定义(类型_整数)
   主线程返回值地址->对象->整数值 = 返回值
   
   Erase 线程表
   
   TerminateThread(主线程句柄 ,0)
End Sub


Sub 取栈参数(执行栈() As 栈类型 ,ByRef 执行栈顶 As Integer ,存放容器() As 栈类型 ,数量 As Integer)
   ReDim 存放容器(数量-1)
   For i As Integer = 数量-1 To 0 Step-1
      弹出(执行栈 ,执行栈顶 ,存放容器(i))
   Next
End Sub

Sub 线程回收 stdcall(ptr_data As Any Ptr)
   Dim 线程ID   As DWORD  = Peek(DWORD ,ptr_data)
   Dim 线程句柄 As HANDLE = Peek(HANDLE ,ptr_data + SizeOf(DWORD))
   
   Deallocate(ptr_data)
   
   WaitForSingleObject(线程句柄 , -1)
   
   If 调试模式 Then
      发送调试信息(Fly_ThreadStop ,线程ID)
   End If
   
   删除线程(线程ID)
   
End Sub

Sub FlyDebug Overload(错误信息 As String)
   MsgBox(错误信息 ,16 ,"Fly Debug")
   
   ExitProcess(0)
End Sub

Sub FlyDebug Overload(错误信息 As String,IP As LongInt)
   MsgBox(错误信息 ,16 ,"Fly Debug IP:" + Str(IP))
   
   ExitProcess(0)
   
End Sub

